#' Bernoulli candidate model that is a function of component
#' cause of failure.
#'
#' Bernoulli candidate model that is a function of component
#' cause of failure \code{k} and parameters \code{alpha} and \code{gamma},
#' where if component cause of failure is indexed by \code{j}, then \code{j} is
#' in the candidate set with probability \code{alpha[j]}, and otherwise
#' the component indexed by \code{j} is in the candidate set with probability
#' \code{gamma[j]}.
#'
#' If \code{all(alpha) = 1} then candidate sets satisfy C1.
#' If \code{all(gamma) = p} then candidiate sets satisfy C2.
#' Also, since we treat \code{gamma} as a numeric vector, it is not a function
#' of \code{theta} and therefore candidate sets satisfy C3.
#'
#' @param md masked dataa data column 'k' for failed component and 'x'
#'           for candidate sets
#' @param gamma probability vector
#' @param alpha probability vector, defaults to all 1's.
#' @importFrom md.tools md_decode_matrix
#' @importFrom dplyr %>%
#' @importFrom dplyr bind_cols
#' @importFrom tibble as_tibble
#' @importFrom stats runif
#' @export
md_bernoulli_candidate_alpha_C1_C3 <- function(md,gamma=NULL,alpha=NULL)
{
    stopifnot(!is.null(md$k))
    n <- nrow(md)
    stopifnot(n > 0)

    m <- length(gamma)
    if (is.null(gamma))
        gamma <- rep(.5,m)
    stopifnot(all(gamma >= 0) && all(gamma <= 1))

    if (is.null(alpha))
        alpha <- rep(1,n)
    stopifnot(all(alpha >= 0) && all(alpha <= 1))
    stopifnot(n == length(alpha))

    u <- matrix(runif(m*n,0,1),nrow=n)
    x <- matrix(rep(F,m*n),nrow=n)

    for (i in 1:n)
    {
        for (j in 1:m)
        {
            if(md$k[i] == j)
            {
                if (u[i,j] < alpha[j])
                    x[i,j] <- T
            }
            else if (u[i,j] < gamma[j])
                x[i,j] <- T
        }
    }

    x <- as_tibble(x)
    colnames(x) <- paste0("x",1:m)
    md %>% bind_cols(x)
}





#' Bernoulli candidate model that is a function of component
#' cause of failure and satisfies conditions \code{C1}, code{C2}, and \code{C3}.
#'
#' Bernoulli candidate model that is a function of component
#' cause of failure \code{k} and parameters \code{alpha} and \code{epsilon},
#' where if component cause of failure is indexed by \code{j}, then \code{j} is
#' in the candidate set with probability \code{alpha[j]}.
#'
#' - If \code{alpha} is approximately \code{1}, then candidate sets
#'   approximately satisfy \code{C1}.
#'
#' - If \code{epsilon} is sufficiently small, say \code{1e-3}, then candidate
#'   sets approximately satisfy \code{C2}.
#'
#' - Candidate sets generated by this procedure always satisfy \code{C3}.
#'
#' @param k component cause of failure.
#' @param m number of components in the system
#' @param alpha defaults to \code{1}.
#' @param epsilon defaults to \code{1e-3}.
#' @importFrom dplyr %>%
#' @importFrom dplyr bind_cols
#' @importFrom tibble as_tibble
#' @importFrom stats runif
#' @export
md_bernoulli_candidate_set_exp_series_generator <- function(
        k,m,alpha=1,epsilon=1e-3)
{
    stopifnot(m >= 0)
    stopifnot(k > 0 && k <= m)
    stopifnot(alpha >= 0 && alpha <= 1)
    stopifnot(epsilon >= 0 && epsilon <= 1)
    stopifnot(!is.null(md$k))
    n <- nrow(md)
    stopifnot(n > 0)

    x <- logical(m)
    repeat
    {
        u <- runif(m)
        p <- runif(m)
        for (j in 1:m)
            x[j] <- ifelse(k == j, u[j] < alpha, u[j] < p[j])
    }

    x <- as_tibble(x)
    colnames(x) <- paste0("x",1:m)
    md %>% bind_cols(x)
}
